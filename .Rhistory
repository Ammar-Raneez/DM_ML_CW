clusplot(scaled_vehicle_data, elbow_kmean$cluster, color = T, shade = T, labels = 4)
## KMEANS ANALYSIS ##
set.seed(101)
#Elbow
elbow_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 4, nstart = 50)
library(readxl)
library(factoextra)
library(NbClust)
library(caret)
library(ggplot2)
library(cluster)
#read in the data
vehicle_data <- read_excel("../../vehicles.xlsx")
#remove samples column due to it only being a counter
vehicle_data <- vehicle_data[c(-1)]
#data type
class(vehicle_data)
#any missing values?
sum(is.na(vehicle_data))
## DATA PREPROCESSING SECTION ##
#normalize the input features
scaled_vehicle_data <- apply(vehicle_data[-c(ncol(vehicle_data))], 2, scale)
#bind the class column back into the normalized data set
scaled_vehicle_data <- cbind(scaled_vehicle_data, vehicle_data[c(ncol(vehicle_data))])
#visualize outliers of data set
boxplot(scaled_vehicle_data[-c(ncol(vehicle_data))], las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
#Based on box plot, following columns have outliers
have_outliers <- c("Rad.Ra", "Pr.Axis.Ra", "Max.L.Ra", "Pr.Axis.Rect", "Sc.Var.Maxis", "Sc.Var.maxis", "Skew.Maxis", "Skew.maxis", "Kurt.maxis")
#loop through all the columns that have outliers
for (outlier in have_outliers) {
number_of_rows = nrow(scaled_vehicle_data)
#get quantile values - 25th and 75th percentiles
quant <- quantile(scaled_vehicle_data[, outlier], probs = c(0.25, 0.75))
#calculate IQR for the respective columns
iqr <- IQR(scaled_vehicle_data[1:number_of_rows, outlier])
#An outlier is a point below lower quartile and above upper quartile
upper_quartile <- quant[2] + 1.5*iqr
lower_quartile <- quant[1] - 1.5*iqr
#subset the data set, such that the outliers are filtered out
scaled_vehicle_data <- subset(
scaled_vehicle_data,
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] > lower_quartile &
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] < upper_quartile
)
}
#data set can now be split into input and output
scaled_vehicle_data_inputs <- scaled_vehicle_data[c(-ncol(vehicle_data))]
scaled_vehicle_data_output <- scaled_vehicle_data[c(ncol(vehicle_data))]
#plot box plot again to check whether outliers have been removed
boxplot(scaled_vehicle_data_inputs, las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
## KMEANS CLUSTER DEFINITION ##
#Manual
manual_cluster_size <- 4
#Elbow Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "wss") + labs(subtitle = "Elbow")
#Silhouette Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "silhouette") + labs(subtitle = "Silhouette")
#Gap statistic Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "gap_stat", verbose = F) + labs(subtitle = "Gap statistic")
## KMEANS ANALYSIS ##
set.seed(101)
#Manual
manual_kmean <- kmeans(scaled_vehicle_data_inputs, centers = manual_cluster_size, nstart = 50)
clusplot(scaled_vehicle_data, manual_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_manual <- table(manual_kmean$cluster, scaled_vehicle_data_output$Class)
set.seed(102)
#Elbow
elbow_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 4, nstart = 50)
clusplot(scaled_vehicle_data, elbow_kmean$cluster, color = T, shade = T, labels = 4)
#read in the data
vehicle_data <- read_excel("../../vehicles.xlsx")
#remove samples column due to it only being a counter
vehicle_data <- vehicle_data[c(-1)]
#data type
class(vehicle_data)
#any missing values?
sum(is.na(vehicle_data))
## DATA PREPROCESSING SECTION ##
#normalize the input features
scaled_vehicle_data <- apply(vehicle_data[-c(ncol(vehicle_data))], 2, scale)
#bind the class column back into the normalized data set
scaled_vehicle_data <- cbind(scaled_vehicle_data, vehicle_data[c(ncol(vehicle_data))])
#visualize outliers of data set
boxplot(scaled_vehicle_data[-c(ncol(vehicle_data))], las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
#Based on box plot, following columns have outliers
have_outliers <- c("Rad.Ra", "Pr.Axis.Ra", "Max.L.Ra", "Pr.Axis.Rect", "Sc.Var.Maxis", "Sc.Var.maxis", "Skew.Maxis", "Skew.maxis", "Kurt.maxis")
#loop through all the columns that have outliers
for (outlier in have_outliers) {
number_of_rows = nrow(scaled_vehicle_data)
#get quantile values - 25th and 75th percentiles
quant <- quantile(scaled_vehicle_data[, outlier], probs = c(0.25, 0.75))
#calculate IQR for the respective columns
iqr <- IQR(scaled_vehicle_data[1:number_of_rows, outlier])
#An outlier is a point below lower quartile and above upper quartile
upper_quartile <- quant[2] + 1.5*iqr
lower_quartile <- quant[1] - 1.5*iqr
#subset the data set, such that the outliers are filtered out
scaled_vehicle_data <- subset(
scaled_vehicle_data,
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] > lower_quartile &
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] < upper_quartile
)
}
#data set can now be split into input and output
scaled_vehicle_data_inputs <- scaled_vehicle_data[c(-ncol(vehicle_data))]
scaled_vehicle_data_output <- scaled_vehicle_data[c(ncol(vehicle_data))]
#plot box plot again to check whether outliers have been removed
boxplot(scaled_vehicle_data_inputs, las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
## KMEANS CLUSTER DEFINITION ##
#Manual
manual_cluster_size <- 4
#Elbow Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "wss") + labs(subtitle = "Elbow")
#Silhouette Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "silhouette") + labs(subtitle = "Silhouette")
#Gap statistic Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "gap_stat", verbose = F) + labs(subtitle = "Gap statistic")
## KMEANS ANALYSIS ##
set.seed(101)
#Manual
manual_kmean <- kmeans(scaled_vehicle_data_inputs, centers = manual_cluster_size, nstart = 50)
clusplot(scaled_vehicle_data, manual_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_manual <- table(manual_kmean$cluster, scaled_vehicle_data_output$Class)
set.seed(102)
#Elbow
elbow_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 3, nstart = 50)
clusplot(scaled_vehicle_data, elbow_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_elbow <- table(elbow_kmean$cluster, scaled_vehicle_data_output$Class)
set.seed(103)
#Silhouette & Gap Stat
silhouette_gap_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 2, nstart = 50)
clusplot(scaled_vehicle_data, silhouette_gap_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_silhouette_gap <- table(silhouette_gap_kmean$cluster, scaled_vehicle_data_output$Class)
#Visualize data and classes
ggplot(scaled_vehicle_data, aes(Rad.Ra, Pr.Axis.Ra)) + geom_point(aes(col=Class), size = 3)
#table evaluations for each method
comparison_table_manual
comparison_table_elbow
comparison_table_silhouette_gap
comparison_table_manual <- table(scaled_vehicle_data_output$Class, manual_kmean$cluster)
comparison_table_elbow <- table(scaled_vehicle_data_output$Class, elbow_kmean$cluster)
comparison_table_silhouette_gap <- table(scaled_vehicle_data_output$Class, silhouette_gap_kmean$cluster)
#table evaluations for each method
comparison_table_manual
comparison_table_elbow
comparison_table_silhouette_gap
comparison_table_manual <- table(scaled_vehicle_data_output$Class, manual_kmean$cluster)
comparison_table_elbow <- table(scaled_vehicle_data_output$Class, elbow_kmean$cluster)
comparison_table_silhouette_gap <- table(scaled_vehicle_data_output$Class, silhouette_gap_kmean$cluster)
#Visualize data and classes
ggplot(scaled_vehicle_data, aes(Rad.Ra, Pr.Axis.Ra)) + geom_point(aes(col=Class), size = 3)
#table evaluations for each method
comparison_table_manual
comparison_table_elbow
comparison_table_silhouette_gap
#Manual
manual_kmean <- kmeans(scaled_vehicle_data_inputs, centers = manual_cluster_size, nstart = 50)
clusplot(scaled_vehicle_data, manual_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_manual <- table(scaled_vehicle_data_output$Class, manual_kmean$cluster)
#table evaluations for each method
comparison_table_manual
#read in the data
vehicle_data <- read_excel("../../vehicles.xlsx")
#remove samples column due to it only being a counter
vehicle_data <- vehicle_data[c(-1)]
#data type
class(vehicle_data)
#any missing values?
sum(is.na(vehicle_data))
## DATA PREPROCESSING SECTION ##
#normalize the input features
scaled_vehicle_data <- apply(vehicle_data[-c(ncol(vehicle_data))], 2, scale)
#bind the class column back into the normalized data set
scaled_vehicle_data <- cbind(scaled_vehicle_data, vehicle_data[c(ncol(vehicle_data))])
#visualize outliers of data set
boxplot(scaled_vehicle_data[-c(ncol(vehicle_data))], las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
#Based on box plot, following columns have outliers
have_outliers <- c("Rad.Ra", "Pr.Axis.Ra", "Max.L.Ra", "Pr.Axis.Rect", "Sc.Var.Maxis", "Sc.Var.maxis", "Skew.Maxis", "Skew.maxis", "Kurt.maxis")
#loop through all the columns that have outliers
for (outlier in have_outliers) {
number_of_rows = nrow(scaled_vehicle_data)
#get quantile values - 25th and 75th percentiles
quant <- quantile(scaled_vehicle_data[, outlier], probs = c(0.25, 0.75))
#calculate IQR for the respective columns
iqr <- IQR(scaled_vehicle_data[1:number_of_rows, outlier])
#An outlier is a point below lower quartile and above upper quartile
upper_quartile <- quant[2] + 1.5*iqr
lower_quartile <- quant[1] - 1.5*iqr
#subset the data set, such that the outliers are filtered out
scaled_vehicle_data <- subset(
scaled_vehicle_data,
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] > lower_quartile &
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] < upper_quartile
)
}
#data set can now be split into input and output
scaled_vehicle_data_inputs <- scaled_vehicle_data[c(-ncol(vehicle_data))]
scaled_vehicle_data_output <- scaled_vehicle_data[c(ncol(vehicle_data))]
#plot box plot again to check whether outliers have been removed
boxplot(scaled_vehicle_data_inputs, las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
## KMEANS CLUSTER DEFINITION ##
#Manual
manual_cluster_size <- 4
#Elbow Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "wss") + labs(subtitle = "Elbow")
#Silhouette Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "silhouette") + labs(subtitle = "Silhouette")
#Gap statistic Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "gap_stat", verbose = F) + labs(subtitle = "Gap statistic")
## KMEANS ANALYSIS ##
set.seed(101)
#Manual
manual_kmean <- kmeans(scaled_vehicle_data_inputs, centers = manual_cluster_size, nstart = 50)
clusplot(scaled_vehicle_data, manual_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_manual <- table(scaled_vehicle_data_output$Class, manual_kmean$cluster)
set.seed(102)
#Elbow
elbow_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 3, nstart = 50)
clusplot(scaled_vehicle_data, elbow_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_elbow <- table(scaled_vehicle_data_output$Class, elbow_kmean$cluster)
set.seed(103)
#Silhouette & Gap Stat
silhouette_gap_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 2, nstart = 50)
clusplot(scaled_vehicle_data, silhouette_gap_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_silhouette_gap <- table(scaled_vehicle_data_output$Class, silhouette_gap_kmean$cluster)
#Visualize data and classes
ggplot(scaled_vehicle_data, aes(Rad.Ra, Pr.Axis.Ra)) + geom_point(aes(col=Class), size = 3)
#table evaluations for each method
comparison_table_manual
comparison_table_elbow
comparison_table_silhouette_gap
#table evaluations for each method
comparison_table_manual[0]
#table evaluations for each method
comparison_table_manual[1]
#table evaluations for each method
comparison_table_manual[1][1]
#table evaluations for each method
comparison_table_manual[1][2]
#table evaluations for each method
comparison_table_manual[2]
#table evaluations for each method
comparison_table_manual[, 2]
#table evaluations for each method
comparison_table_manual[, 1]
#table evaluations for each method
comparison_table_manual[1:1, 1]
#table evaluations for each method
comparison_table_manual[2, 1]
#table evaluations for each method
comparison_table_manual[1, 2]
#table evaluations for each method
comparison_table_manual[1, 3]
colSums(comparison_table_manual)
sum(comparison_table_manual)
#create a function that computes the classification report for the evaluation tables
classification_report <- function(comparison_table, dp = 2) {
ct <- sum(comparison_table)
cs <- colSums(comparison_table)
rs <- rowSums(comparison_table)
tp <- diag(comparison_table)
tn <- ct - (rs + cs - tp)
fp <- rs - tp
fn <- cs - tp
pr <- tp / (tp + fp)
re <- tp / (tp + fn)
f1 <- 2 * pr * re / (pr + re)
ac <- sum(tp) / ct
list(summary=round(data.frame(precision=pr, recall=re, f1_score=f1, support=cs), dp),
accuracy=round(ac, dp),
support=ct)
}
classification_report(comparison_table = comparison_table_manual)
classification_report(comparison_table = comparison_table_elbow)
classification_report(comparison_table = comparison_table_silhouette_gap)
precision(comparison_table_manual)
classification_report(comparison_table = comparison_table_silhouette_gap)
diag(comparison_table_elbow)
confusionMatrix(data = silhouette_gap_kmean$cluster, reference = scaled_vehicle_data_output$Class)
class(scaled_vehicle_data_output$Class)
class(silhouette_gap_kmean$cluster)
scaled_vehicle_data_output$Class
as.integer(scaled_vehicle_data_output$Class)
as.integer(scaled_vehicle_data_output$Class == 'Van')
as.integer(scaled_vehicle_data_output$Class == 'van')
as.integer(scaled_vehicle_data_output$Class = 'van' ? 1 : 0)
as.integer(scaled_vehicle_data_output$Class == 'van' ? 1 : 0)
as.factor(scaled_vehicle_data_output$Class)
abc <- as.factor(scaled_vehicle_data_output$Class)
levels(abc) <- relevel(abc, ref = "van")
abc
levels(abc) <- relevel(1, ref = "van")
levels(abc) <- relevel(abc, ref = 1)
abc
abc <- as.factor(scaled_vehicle_data_output$Class)
abc
efg <- as.factor(scaled_vehicle_data_output$Class)
confusionMatrix(data = efg, reference = abc)
efg <- as.factor(silhouette_gap_kmean$cluster$Class)
confusionMatrix(data = efg, reference = abc)
abc <- as.factor(scaled_vehicle_data_output$Class)
efg <- as.factor(silhouette_gap_kmean$cluster$Class)
efg <- as.factor(silhouette_gap_kmean$cluster)
confusionMatrix(data = efg, reference = abc)
abc <- as.factor(scaled_vehicle_data_output$Class)
efg <- as.factor(silhouette_gap_kmean$cluster)
confusionMatrix(data = efg, reference = abc)
abc
efg
efg <- as.factor(manual_kmean$cluster)
abc
efg
confusionMatrix(data = efg, reference = abc)
efg <- as.factor(manual_kmean$cluster)
as.numeric(efg)
efg <- as.factor(efg)
efg
confusionMatrix(data = efg, reference = abc)
abc
as.numeric(abc)
efg
abc
abc <- as.factor(scaled_vehicle_data_output$Class)
efg <- as.factor(manual_kmean$cluster)
abc <- as.numeric(abc)
efg
abc
confusionMatrix(data = efg, reference = abc)
abc <- as.factor(scaled_vehicle_data_output$Class)
efg <- as.factor(manual_kmean$cluster)
abc <- as.numeric(abc)
abc <- as.factor(abc)
confusionMatrix(data = efg, reference = abc)
confusionMatrix(data = efg, reference = abc, mode = 'prec_recall')
abc <- as.factor(scaled_vehicle_data_output$Class)
efg <- as.factor(silhouette_gap_kmean$cluster)
abc <- as.numeric(abc)
abc <- as.factor(abc)
confusionMatrix(data = efg, reference = abc, mode = 'prec_recall')
abc <- as.factor(scaled_vehicle_data_output$Class)
efg <- as.factor(elbow_kmean$cluster)
abc <- as.numeric(abc)
abc <- as.factor(abc)
confusionMatrix(data = efg, reference = abc, mode = 'prec_recall')
classification_report(comparison_table = elbow_kmean)
#create a function that computes the classification report for the evaluation tables
classification_report <- function(comparison_table, dp = 2) {
#total counts
counts <- sum(comparison_table)
#total sums for each column
column_sums <- colSums(comparison_table)
#total sums for each row
row_sums <- rowSums(comparison_table)
#true positive value
tp <- diag(comparison_table)
#true negative
tn <- counts - (column_sums + row_sums - tp)
#false positive
fp <- row_sums - tp
#false negative
fn <- column_sums - tp
#precision
pr <- tp / (tp + fp)
#recall
re <- tp / (tp + fn)
#f1 score
f1 <- 2 * pr * re / (pr + re)
#accuracy
ac <- sum(tp) / counts
list(summary=round(data.frame(precision=pr, recall=re, f1_score=f1, support=cs), dp), accuracy=round(ac, dp), support=counts)
}
classification_report(comparison_table = elbow_kmean)
ground_truth_as_factor <- as.factor(scaled_vehicle_data_output$Class)
elbow_predictions_as_factor <- as.factor(manual_kmean$cluster)
#since the predictions comes out as 1,2,3,4, The categorical data of the ground truth is converted to numerical
ground_truth_as_numeric <- as.numeric(ground_truth_as_factor)
#the data type has to be changed back to factor, since CM can accept only factors
ground_truth_as_factor <- as.factor(ground_truth_as_numeric)
confusionMatrix(data = elbow_predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
#read in the data
vehicle_data <- read_excel("../../vehicles.xlsx")
#remove samples column due to it only being a counter
vehicle_data <- vehicle_data[c(-1)]
#data type
class(vehicle_data)
#any missing values?
sum(is.na(vehicle_data))
## DATA PREPROCESSING SECTION ##
#normalize the input features
scaled_vehicle_data <- apply(vehicle_data[-c(ncol(vehicle_data))], 2, scale)
#bind the class column back into the normalized data set
scaled_vehicle_data <- cbind(scaled_vehicle_data, vehicle_data[c(ncol(vehicle_data))])
View(scaled_vehicle_data)
#visualize outliers of data set
boxplot(scaled_vehicle_data[-c(ncol(vehicle_data))], las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
#Based on box plot, following columns have outliers
have_outliers <- c("Rad.Ra", "Pr.Axis.Ra", "Max.L.Ra", "Pr.Axis.Rect", "Sc.Var.Maxis", "Sc.Var.maxis", "Skew.Maxis", "Skew.maxis", "Kurt.maxis")
#loop through all the columns that have outliers
for (outlier in have_outliers) {
number_of_rows = nrow(scaled_vehicle_data)
#get quantile values - 25th and 75th percentiles
quant <- quantile(scaled_vehicle_data[, outlier], probs = c(0.25, 0.75))
#calculate IQR for the respective columns
iqr <- IQR(scaled_vehicle_data[1:number_of_rows, outlier])
#An outlier is a point below lower quartile and above upper quartile
upper_quartile <- quant[2] + 1.5*iqr
lower_quartile <- quant[1] - 1.5*iqr
#subset the data set, such that the outliers are filtered out
scaled_vehicle_data <- subset(
scaled_vehicle_data,
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] > lower_quartile &
scaled_vehicle_data[c(-ncol(vehicle_data))][, outlier] < upper_quartile
)
}
#data set can now be split into input and output
scaled_vehicle_data_inputs <- scaled_vehicle_data[c(-ncol(vehicle_data))]
scaled_vehicle_data_output <- scaled_vehicle_data[c(ncol(vehicle_data))]
View(scaled_vehicle_data_output)
View(scaled_vehicle_data_inputs)
#plot box plot again to check whether outliers have been removed
boxplot(scaled_vehicle_data_inputs, las = 2, col = c("lightgreen", "lightblue"), ylab = "Normalized Values")
View(scaled_vehicle_data_output)
summary(vehicle_data)
## KMEANS CLUSTER DEFINITION ##
#Manual
manual_cluster_size <- 4
#Elbow Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "wss") + labs(subtitle = "Elbow")
#Silhouette Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "silhouette") + labs(subtitle = "Silhouette")
#Gap statistic Method
fviz_nbclust(scaled_vehicle_data_inputs, kmeans, method = "gap_stat", verbose = F) + labs(subtitle = "Gap statistic")
## KMEANS ANALYSIS ##
#set seed for reproducible runs
set.seed(101)
#Manual
manual_kmean <- kmeans(scaled_vehicle_data_inputs, centers = manual_cluster_size, nstart = 50)
clusplot(scaled_vehicle_data, manual_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_manual <- table(scaled_vehicle_data_output$Class, manual_kmean$cluster)
set.seed(102)
#Elbow
elbow_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 3, nstart = 50)
clusplot(scaled_vehicle_data, elbow_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_elbow <- table(scaled_vehicle_data_output$Class, elbow_kmean$cluster)
set.seed(103)
#Silhouette & Gap Stat
silhouette_gap_kmean <- kmeans(scaled_vehicle_data_inputs, centers = 2, nstart = 50)
clusplot(scaled_vehicle_data, silhouette_gap_kmean$cluster, color = T, shade = T, labels = 4)
comparison_table_silhouette_gap <- table(scaled_vehicle_data_output$Class, silhouette_gap_kmean$cluster)
ground_truth_as_factor <- as.factor(scaled_vehicle_data_output$Class)
ground_truth_as_factor
predictions_as_factor <- as.factor(manual_kmean$cluster)
predictions_as_factor
#since the predictions comes out as 1,2,3,4, The categorical data of the ground truth is converted to numerical
ground_truth_as_numeric <- as.numeric(ground_truth_as_factor)
#the data type has to be changed back to factor, since CM can accept only factors
ground_truth_as_factor <- as.factor(ground_truth_as_numeric)
ground_truth_as_factor
len(ground_truth_as_factor)
length(ground_truth_as_factor)
length(predictions_as_factor)
confusionMatrix(data = predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
#convert to factors, since confusion matrix expects factors
ground_truth_as_factor <- as.factor(scaled_vehicle_data_output$Class)
predictions_as_factor <- as.factor(elbow_kmean$cluster)
#since the predictions comes out as 1,2,3,4, The categorical data of the ground truth is converted to numerical
ground_truth_as_numeric <- as.numeric(ground_truth_as_factor)
#the data type has to be changed back to factor, since CM can accept only factors
ground_truth_as_factor <- as.factor(ground_truth_as_numeric)
confusionMatrix(data = predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
confusionMatrix(data = predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
#convert to factors, since confusion matrix expects factors
ground_truth_as_factor <- as.factor(scaled_vehicle_data_output$Class)
predictions_as_factor <- as.factor(elbow_kmean$cluster)
#since the predictions comes out as 1,2,3,4, The categorical data of the ground truth is converted to numerical
ground_truth_as_numeric <- as.numeric(ground_truth_as_factor)
#the data type has to be changed back to factor, since CM can accept only factors
ground_truth_as_factor <- as.factor(ground_truth_as_numeric)
confusionMatrix(data = predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
#convert to factors, since confusion matrix expects factors
ground_truth_as_factor <- as.factor(scaled_vehicle_data_output$Class)
predictions_as_factor <- as.factor(silhouette_gap_kmean$cluster)
#since the predictions comes out as 1,2,3,4, The categorical data of the ground truth is converted to numerical
ground_truth_as_numeric <- as.numeric(ground_truth_as_factor)
#the data type has to be changed back to factor, since CM can accept only factors
ground_truth_as_factor <- as.factor(ground_truth_as_numeric)
confusionMatrix(data = predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
cr <- function(cm, dp=2) {
ct <- sum(cm)
cs <- colSums(cm)
rs <- rowSums(cm)
tp <- diag(cm)
tn <- ct - (rs + cs - tp)
fp <- rs - tp
fn <- cs - tp
pr <- tp / (tp + fp)
re <- tp / (tp + fn)
f1 <- 2 * pr * re / (pr + re)
ac <- sum(tp) / ct
list(summary=round(data.frame(tp, tn, fp, fn, precision=pr, recall=re, f1_score=f1, support=cs), dp),
accuracy=round(ac, dp),
support=ct)
}
cr(manual_kmean)
cr(comparison_table_manual)
predictions_as_factor <- as.factor(elbow_kmean$cluster)
confusionMatrix(data = predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
predictions_as_factor <- as.factor(silhouette_gap_kmean$cluster)
confusionMatrix(data = predictions_as_factor, reference = ground_truth_as_factor, mode = 'prec_recall')
View(elbow_kmean)
View(elbow_kmean)
elbow_kmean[["centers"]]
